---
title: "Avond Sessie 02: Data preparation"
subtitle: "Inleiding R"
author: "Longhow Lam"
output: 
  html_notebook:
    theme: sandstone
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
#output:
#  prettydoc::html_pretty:
#    highlight: github
#    theme: cayman
#    toc: true
#    toc_depth: 2
#    number_sections: true
---

---

<br>


# The tidyverse

---


Een verzameling R packages met 'dezelfde' gedachtegoed om data te bewerken / manipuleren. installeer tidyverse en attach de library zodat je in 1 keer een aantal libraries laadt

* dplyr
* tibble
* ggplot2
* purr
* forcats
* readr
* readxl
* stringr
* tidyr

```{r, eval=FALSE, include=FALSE}
library(tidyverse)
```


# dplyr

---

Dit package is ontzettend handig om data te bewerken in R. De syntax is elegant en dplyr code kan je in sommige gevallen ook gebruiken voor data die niet in R zit. Bijvoorbeeld, data in Spark kan je met dplyr code bewerken. Er zijn veel 'sleutel' woorden, maar de belangrijkste zijn `select`,  `filter`, `mutate`, `arrange`, `summarize`, `slice` en `rename`. 

Het mooie is dat deze sleutel woorden ook achter elkaar gebruikt kunnen worden met de `%>%` chain operator.


## kolommen selecteren met select

```{r, eval=FALSE}
## enkele kolommen selecteren
my.cars = select(mtcars, hp, mpg, drat)

## via de chain operator, dit is niet alleen handig maar zo kan je verschillende operaties achter elkaar plakken.
my.cars = mtcars %>% 
  select(hp, mpg, drat)

## meerdere kolommen selecteren
test1 = iris %>% 
  select(
    starts_with("Petal")
  )

## bepaalde kolommen selecteren
test2 = mtcars %>% 
  select(
    contains("pg"),
    starts_with("c")
  )

my.cars = mtcars %>% .[2:6]

```

## kolom maken of wijzigen met mutate

We zagen al dat je kolommen kon wijzigen met `$` 

```{r}
my.cars$kolom2  = rnorm(32)
my.cars$kolom3  = my.cars$kolom2 + 9
```

Maar met `mutate` kan je dit veel eleganter doen

```{r}
mycars = mtcars %>%
  select(
    disp, 
    mpg 
  ) %>%
  mutate(
    displ_l = disp / 61.0237,
    tmp = mpg *1000
  )

```


Je kan nieuwe kolommen maken die afhankelijk zijn van kolommen die je net in mutate maakt

```{r}
mycars = mtcars %>%
  mutate(
    displ_l = disp / 61.0237,
    tmp = mpg *1000,
    tmp2 = tmp + 1
  )

```

Twee functies die ontzettend handig kunnen zijn: `mutate_at` en `mutate_if`

```{r}
ABT = ABT %>% mutate_at(4:34, funs(. / ntotalclicks))
mutate_if()
```



## distinct rows

Soms wil je data ontdubbelen, dit kan je in R doen met de functie distinct

```{r}
distinct( select(mtcars, carb, gear))

distinct(select(mtcars, 10,11))

### pipe / chain operatie
myset = mtcars %>% 
  select(10,11) %>%
  distinct
```


## data sets filteren

```{r, eval=FALSE, include=FALSE}
### data filteren met filter
filter(mtcars, cyl == 8 & gear > 3)

```

## data sets aggregeren
aggregeren met de functie group_by en summarise  deze gaan hand in hand samen

```{r}
by_cyl = group_by(mtcars, cyl) 
class(by_cyl)


summarise(by_cyl, Naampje1 = mean(disp), Naampje2 = mean(hp))


out = group_by(mtcars, cyl) %>% 
  summarise( mean(disp), mean(hp))


out = filter(mtcars, mpg > 11) %>%
        group_by(cyl, carb) %>% 
        summarise( N = n(), MeanDisp = mean(disp), SD_HP = sd(hp)) %>%
        
  
df1 = data.frame(x=1:100,y=rnorm(100))
df2 = data.frame(x=51:150, z=rnorm(100))

df3 = left_join(df1, df2, by = "x")
```



## joins
```{r, eval=FALSE, include=FALSE}
df1 = data.frame(col1 = c(1,2,3,4,5), tt = rnorm(5))
df2 = data.frame(col2 = c(3,4,5,6,7), xx = rnorm(5))

inner_join(df1, df2, by = c("col1" = "col2"))
left_join(df1, df2, by = c("col1" = "col2"))
right_join(df1, df2, by = c("col1" = "col2"))

anti_join(df1, df2, by = c("col1" = "col2"))
full_join(df1, df2, by = c("col1" = "col2"))
```


<br>

# tidy data en wide data

---

Tidy data is wanneer data in de volgende vorm zit:

* Elke variabele is in een kolom.
* Elke observatie is een rij.
* Elke waarde is een cel.

Stel we hebben de volgende data set

```{r}
library(tidyr)
stocks <- data.frame(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)
stocks
```

Soms is het handig om data waarden in 1 kolom te hebben en een aprte variabele die de variabele weergeeft

```{r}
stocksm <- stocks %>% gather(stock, price, -time)
stocksm
```

en spread is het omgekeerde process

```{r}
stock2 = stocksm %>% spread(stock, price)
stock2
 
## als er niet even veel observaties zijn?

test = data.frame(
  T = c(1,2,3,1,2), 
  V = c("A","A","A","B","B"),
  price = c(4,5,6,7,8)
)

test2 = test %>% spread(V,price)
```

<br>


# stringr

---

Character data in R kan je bewerken/manipuleren met het `stringr` package. Voordat we daar verder op in gaan is het handig om te weten wat reguliere expressies zijn.

## Reguliere expressies

Dit is een soort 'mini' taaltje om character patronen te formuleren

```{r}
test = c("dit is een 1628EP postcode test", "foutje?:  0234XD", "dit is er nog een 1628 EP", "en nog een foute 126EP", "nog een 1234    XX", "1234eZ en nog 4567PK")
test

# Hoe haal je de goede postcodes er uit?


# zie ook help bij grep 
```

Sommige mensen zijn de wildcard notatie gewend om te zoeken in strings, deze wildcard notatie kan je vertalen naar reguliere expressies met `glob2rx`. Een paar voorbeelden zullen hieronder geven. 

```{r}
glob2rx()
```

Voor een cheatsheet over reguliere expressies zie [regex cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf)

## functies uit het package stringr


str_locate
str_locate_all

str_sub
str_length

str_match

str_detect
str_trim

str_replace
str_repalce_all
str_tolower

```{r}

titanic::titanic_train
## maak extra kolom aan in titanic die namen zoekt
mutate
```

<br>

# forcats

---


<br>

# Dates in R

---


Voor datums in R zijn de packages `anydate` en `lubridate` heel handig.

```{r}



```



