---
title: 'Avond Sessie 01: Data types/structures'
subtitle: "Inleiding R"
author: "Longhow Lam"
output: 
  html_notebook:
    theme: sandstone
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
#output:
#  prettydoc::html_pretty:
#    highlight: github
#    theme: cayman
#    toc: true
#    toc_depth: 2
#    number_sections: true
---

---

<br>


# Inleding

---

## De RStudio omgeving

Begin met powerpoint slides over R en R Studio

* Rstudio
* Environment tab (Object browser)
* packages

## R Projecten

Organiseer je R werk in projecten. Een project kan bestaan uit verschillende scripts, data en output, deze wil je handig in 1 folder hebben. In RStudio kan je heel handig met verschillende R projecten werken. Via de GUI kun je nieuwe projecten aanmaken en beheren.  


## Scripts 

Scripts, zijn gewone tekst files (*.R) met R code. In RStudio kan je meerdere scripts openen en bewerken. Scripts die bij elkaar horen kan je in een R Project zetten.

* Handy shortcuts
* Find in files.... 
* Code folding


## R Notebooks

R notebooks bevatten meer dan alleen R code, het is een 'compleet' document met R code, output en een beschrijvende verhaallijn. In een R project kun je ook meerdere van deze notebooks en scripts beheren. Notebooks maak je met Rmarkdown, een soort light weight markup language. Deze R cursus werkt met notebooks. Een notebook bevat R code chunks die je kan runnen.

Een R notebook kan je "knit" ('breien') tot een html/pdf/word document.

## Een paar simpele expressie

Hieronder een paar simpele expressies in R om te beginnen


```{r, eval=FALSE}
1 + 1
print("hello world")

## assignment kan je = of <- gebruiken
test = 9
test

test <- 3
```

In R zijn namen van objecten *case-sensitive!*

```{r, eval=FALSE}
x = 8
X = 8

getwd()
ls()

786 / (87 +87)

pi / asin(1)

exp(1) 
```


Help in R is <F1> op een functie.  F1 op de functie: cut

<br>

# Data types

---

Alle data in R is van een bepaalde type, we zullen de verschillende types hieronder behandelen. met de functie `typeof` kan je het type altijd opvragen van een object in R.

## integer

Integers in R zijn gehele getallen.

```{r, eval=FALSE}
x = 1
y = 2

is.integer(x)

x = as.integer(1)
z = x + 9.78

is.integer(z)

y = 34L
is.integer(y)
```

## character

In R kan je met het `character` data type teksten opslaan. bewerkingen en manipulaties van characters in sessie 2.

```{r, eval=FALSE}
x1 = "Longhow Lam"
x2 = "1628 AA Hoorn"

is.character(x1)

nchar(x2)

x3 = paste(x1, x2)
x3 = paste(x1, x2, sep="")
```


## factor

In R zijn `factors` bedoeld om categorische variabelen te representeren. Denk aan geslacht, of opleiding. Verwar factor niet met character.

```{r, eval=FALSE}
x3 = c("M", "F", "M")

is.character(x3)
typeof(x3)

y3 = as.factor(x3)
x3
y3

# dit is wel apart
typeof(y3)
is.character(y3)
is.factor(y3)
is.integer(y3)

levels(y3)
levels(x3)

# Dus let op het verschil tussen factors en characters!!!!
```

## double

De doubles in R zijn vaak gebruikt om alledaagse data te representeren. Bijvoorbeeld lengte, 1.85 of gewicht 78.8 zijn niet gehele getallen

```{r, eval=FALSE}
x4 = 4
x5 = 5.6 / 8

x6 = pi/2

is.double(x4)

x7 = 4L
is.double(x7)

# in tegenstelling tot sommige andere talen kan je in R double en integers in berekeningen 
# zonder vertalingen gebruiken

x8 = x4 + x7
typeof(x8)
```


## logical

Als je in R een test uitvoert, dan is het resultaat van het type `logical`. We zagen al de functies `is.double` en `is.integer`.

```{r, eval=FALSE}
x7 = TRUE
x8 = FALSE

typeof(x7)

x9 = x6 < 8

is.logical(x9)

x1 = as.integer(1)
x2 = 1

x1
x2

## let op in R kunnen double aan integers gelijk zijn
is.integer(x2)
is.integer(x1)

x1 == x2
```

Het volgende blokje code laat logische operatoren zien.

```{r, eval=FALSE}
TRUE & FALSE    # AND
!TRUE           # NOT
!FALSE
TRUE | FALSE    # OR

# Je kan rekenen met logicals
TRUE + TRUE
FALSE + FALSE + TRUE

### What the F...

0.1 + 0.2 == 0.3

1 + 2 == 3
x = 0.3

sprintf("%.16f", x)
sprintf("%.24f", x)
```


## oneindig

In R is er een speciaal symbool voor oneindig.

```{r, eval=FALSE}
x1 = 9/0
x2 = -x1
x1
is.infinite(x2)
```

## missing value

Missende waarden kunnen in R worden gerepresenteerd met `NA`. Je kan missende doubles, integers etc. hebben.

```{r, eval=FALSE}
x3 = NA

# gebruik is.na om te checken of iets NA is
is.na(x3)

# een rijtje getallen waarbij eentje missend is
x4 = c(1, 2, 3, 4, NA, 5, 7)

# hoeveel elementen zijn NA en niet NA
sum(is.na(x4))
sum(!is.na(x4))

x4 < 4

is.na(x4)
```



## waar zijn mijn objecten

```{r, eval=FALSE}
ls()

objects()
```

wat is een search path...

```{r, eval=FALSE}
Pietje  # wordt niet gevonden
cars # wordt wel gevonden

### Objecten worden volgens een zoekpad gezocht
search()

objects(pos = 5)

## deze worden wel gevonden

OrchardSprays
iris
iris = 9

## wat zit er nu in iris en is mijn oude iris niet weg??
iris
```

Het weghalen van objecten

```{r, eval=FALSE}
x = 5
rm(x)

## standaard alleen objecten weg te halen uit de work directoy, je 'huidige sessie'

iris
rm(iris)

datasets::iris

rm(iris)

########   bewaren van objecten en work directory
x = 45

# bewaar een specifiek object
saveRDS(x, file = "ObjectX.Rds")

# bewaar een heel image,  dit wordt standaard gevraagd als je Rstudio afsluit
save.image()
```

<br>


# Data structures

---

Data in R kan in verschillende vormen verschijnen, de zogenaamde data structuren. We zullen hieronder een aantal basis structuren behandelen.


## vectors

Vectoren worden gebruikt om een 'rijtje' elementen op te slaan. Je kan een vector van doubles hebben, characters etc... Alle elementen kunnen alleen van hetzelfde type zijn!

```{r, eval=FALSE}
## een getal is ook al een vectpr, van lengte 1
x0 = 1

x1 = c( 1, 2, 3, 4, 5)
length(x1)
class(x1)

x2 = c(2L, 3)
typeof(x2)

x3 = c("p", 2)
```

Er zijn diverse functies in R die je kan gebruiken om vectoren te genereren zonder alle elementen een voor een in te typen :-)

```{r, eval = FALSE}
x1 = 1:1000
x1 = 187:278

x2 = seq(1, 50, length=100)

x2a = seq(1,500, by = 20)

## samenvoegen van twee of meer vectoren
x3 = c( x0, rnorm(100))

x4 = sample( letters, rep = TRUE, size = 100)

class(x4)
```

Berekeningen op vectoren gebeuren elements-gewijs

```{r}
y = 3 * x3 + 8

## en wat is dit???
y = x4 + 8

x4 = rep(1:6, 7)
x4 = rep(x4,8)

x5 = rep(1:10, each = 3)
```


### subscripting of vectors

Hoe benader je elementen in een vector? Dat kan met subscripts

```{r, eval=FALSE}
## R begint te tellen bij 1
x3 = 100:200

## subscripts zijn : 1 getal, een vector van getallen, negatieve getallen
x3[1]
x3[  4:10  ]
x3[  -(1:10)]

## gebroken kan ook...
x3[8.9]

## je kan met subscripts ook elementen veranderen
x3[  8:17  ] = 0
```

Een paar simpele functies die je op vectoren kan toepassen

```{r, eval=FALSE}
y = rnorm(1000)

mean(y)
var(y ) 
min(y)
sd(y)
max(y)
summary(y)

sum(y < 0)
```


##  matrices

Een matrix is een verzameling van vectoren die even lang zijn.

```{r, eval=FALSE}
## maak een matrix van een vector
m1 = rnorm(100)
m2 = matrix(m1, byrow = FALSE, ncol=10)
m2
dim(m2)
class(m2)

## maak een matrix van een aantal vectoren
x = 1:10
y = 10:1
z = 11:20

m3 = cbind(x,y,z)
m4 = rbind(x,y,z)
```

Net als vectoren kan je elementen in een matrix benaderen met subscripts, hieronder volgen een aantal voorbeelden.

```{r, eval = FALSE} 
m2[1,5]

m2[  4:10,    3:5]

m2[5,]

m2[ ,5]
```

Matrix berekeningen

```{r, eval =FALSE}
# determinant van een matrix
det(m2)

# matrix transponeren
t(m2)

# inverse van een matrix
solve(m2)

# er zijn twee soorten vermenigvuldigingen van matrices
m2 %*% solve(m2)
m2 * solve(m2)

round(m2 %*% solve(m2))
```

## multidimensional arrays

arrays zijn 3 dimensionale (of hoger) matrices

```{r, eval=FALSE}
m = array(1:1000, dim = c(10,10,10))

m[1,5,7]

m[1,4,  ]

m[,4,]
class(m)
```


## data frames

Een data frame kan je zien als een matrix, maar in tegenstelling tot een matrix, kunnen kolommen van een data frame van een andere type zijn. Voor data analyse met 'echte' data zal een data.frame de meest handige structuur zijn.

```{r, eval=FALSE}
x1 = 1:100
x2 = rnorm(100)
x3 = rnorm(100)
x4 = sample(c("M","F"), size = 100, replace = TRUE)

df1 = data.frame(
  kolomnaampj1 = x1,
  income = x2,
  age = x3,
  type = x4
)

# laat eerste 10 rijen zien
head(df1,10)
```

De volgende functies kan je gebruiken om wat extra info van een data frame te laten zien.

```{r}
# laat de namen van de kolommen zien
names(df1)

# names kan je ook gebruiken om bestaande kolomnamen te wijzigen
df2 = df1
names(df2) = c("A", "B", "C", "D")

# dimensie en classe
dim(df1)
class(df1)

# De levels van kolom 'type' uit mydf
levels(mydf$type)

### pas op met characters die worden standaard in data.frame naar factors omgezet
x4
class(x4)
class(df1$type)

mydf = data.frame(kolomnaampj1 = x1, income = x2, age=x3, type = x4, stringsAsFactors = FALSE)
mydf
class(mydf$type)

## Dit is ook in de Environment viewer te zien
```

Je kan net als bij matrices subscripts gebruiken in data frame om bepaalde data uit een data.frame te halen

```{r, eval=FALSE}
df1[1,3]
df1[11:20,]

df1[, 2:3]
df1$income

## kolom toevoegen
df1$NEW = df1$income / 100
df1
```


## tibles

In R zijn tibles een soort moderne versie van data.frames, afkomstig van Hadley Wickham en er zijn een aantal voordelen om tibbles te gebruiken. Ze hebben een iets betere print methode en transformeren nooit character naar factor

Zie ook zijn boek en de website [tibles.](http://tibble.tidyverse.org/)

```{r, eval=FALSE}
library(tibble)

x1 = 1:100
x2 = rnorm(100)
x3 = rnorm(100)
x4 = sample(c("M","F"), size = 100, replace = TRUE)

tb1 = tibble(
  kolomnaampj1 = x1,
  income = x2,
  age = x3,
  type = x4
)

## output in notebooks is niet verschillend maar in de console zie je dat wel
df1
tb1

## extraheren van column is consistent
df1[,1:2]
df1[,1]

tb1[,1:2]
tb1[,1]
```


## lists

In R zijn lijsten de meest generieke data structuur, het kan beschouwd woorden als een verzameling van andere data structuren. Een lijst kan een lijst bevatten, en lijsten zijn soms het resultaat van een functie die allerlei dingen terug geeft in een lijst.

```{r, eval=FALSE}
m2 = matrix(rnorm(100), ncol=10)
mydf = mtcars

## stop een paar objecten in een lijst
l1 <- list( a = 1, b = 1:100, c = m2, d = mydf)

## een lijst kan weer een lijst bevatten
l2 <- list (zz = rnorm(100), pp = l1)
```

Hoe krijg je dingen weer uit een lijst?

```{r}
## subscripts
l2[[1]]
l2[1]

l2[[2]][[4]][[3]][5:9]

## of bij naam
l1$age[5:9]

l1[[3]]

l1$c[1,4]
l1[[4]]$x2[3]
```

Je kan aan een lijsty extra componenten toevoegen.

```{r}
l1$PP = 1

names(l1)
l1[[6]] = 8

## dit vult de lijst aan met componenten 7, 8 die NULL zijn
l1[[9]] = 100
l1
```


##  functions in R

We zullen hier heel kort functies in R behandelen. Een functie is ook een object zoals we diverse objecten al in R hebben. We kunnen zelf ook een functie schrijven.

```{r, eval=FALSE}
x = 1:10 
y = 1:10

# dit is geen functie....
f1 <- x + y
```

Gebruik `function` om zelf een functie te schrijven. Twee simpele voorbeelden:

```{r}
f1 = function(x, y){
  t1 = 2*y
  t2 = 3*x
  t1 + t2
}

## De laatste regel wordt geretourneerd
f1(8,6)
```


Als je de functie eerder wilt verlaten met een waarde, gebruik dan `return` in de functie.

```{r}
f2 = function(x){
  if (x < 0){
    return(1)
  }
  else
  {
    return(0)
  }
}

f2
f2(-9)

## a simple loop to calculate a sum

f3 = function(x)
{
  n = length(x)

  out = 0  
  for(i in 1:n)
  {
    out = out + x[i] 
  }
  return(out)
}

f3( 1:1000)

# natuurlijk doen we gewoon
sum(1:1000)
```



###   The %>%  pipe (or chain) operator

The chain operator gebruik je om het resultaat van een functie aan een andere functie mee te geven. De code hieronder geeft een heel simpel voorbeeldje

```{r}
tan(cos(sin(0.33)))

0.33 %>% sin %>% cos %>% tan

0.33 %>% 
  sin %>%
  cos %>% 
  tan
```

Meestal wordt dit gebruikt om code leesbaarder te maken en we komen hier in avond sessie 2 verder op terug.

<br>


# Importeren / exporteren van data 

---

Als je met R werkt heb je natuurlijk data nodig, zoals we op bovenstaande manier data hebben gemaakt zal het in de praktijk niet gebeuren met echte data sets. Die leven in data bases of in files

## Inlezen files

Er zijn een aantal packages die handig zijn om files in te lezen.

* `readr` package, voor tekst files
* `haven` package voor files van SAS, SPSS, Stata
* `readxl` voor Excel files

R heeft ook standaard functies voor het inzegen van text files, maar ik gebruik vaak de functies uit het package `readr`. Voor grote files is het veel sneller. En je ziet dan ook een progress bar. In RStudio, kan je de import functies ook aanroepen via de ** Import Dataset ** GUI die het inlezen van data begeleidt.


```{r, eval=FALSE, include=FALSE}
### data met restaurants in Nederland
Restaurants <- read_csv("data/Restaurants.csv")

### Excel files inlezen
library(readxl)
test = read_excel(
  "data/test.xlsx",
  range = "D8:F14"
)
```

## Inlezen uit een data base

Er zijn verschillende packages om data te lezen uit een data base, dit is afhankelijk van de data base. De library `RODBC` gebruik ik bijvoorbeeld om data uit onze SQL Server data base te lezen.

```{r, eval=FALSE}
library(RODBC)
# nodig dat MSSQLSERVER service gestart moet worden

# specificeer connectie
cn <- odbcDriverConnect(connection="Driver={SQL Server Native Client 11.0};server=localhost;database=Testing;trusted_connection=yes;")

sqlTables(cn, schema ="dbo")

RandomPersons = sample_n(VA_RANDOM_PERSONS, 75000)

# haal data uit SQLSERVER
sqlFetch(cn,"cars")

# schrijf weg
sqlSave(cn, RandomPersons)
```


## R Datasets

Je kan R objecten (niet alleen data frames) weg schrijven met de `saveRDS` functie, en deze kunnen weer ingelezen worden met de `readRDS` functie.

```{r}
x = rnorm(100)
saveRDS(x, "data/x.RDs")

rm(x)
x = readRDS("data/x.RDs")

GasPedaal = readRDS("data/AllCarsGasPedaal.Rds")
```


# Nog iets over geheugen gebruik

R verwerkt alles in het RAM geheugen. Het is handig om te weten hoe veel geheugen R verbruikt en hoe groot objecten zijn. Het package `pryr` bevat een aantal handig functies

```{r}
library(pryr)

### hoeveelgeheugen kost een object met 1 miljoen getallen
x = rnorm(1e6)
object_size(x)

### hoeveel geheugen hebben we in totaal verbruikt
mem_used()

### verandering van geheugen
mem_change(
  y <- rnorm(1e7)
)
mem_used()


### verwijder een object
rm(y)
mem_used()

```

