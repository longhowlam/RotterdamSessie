---
title: "Avond Sessie 03: Data visualisatie"
subtitle: "Inleiding R"
author: "Longhow Lam"
output: 
  html_notebook:
    theme: sandstone
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
---

---

<br>


```{r, eval=FALSE, include=FALSE}
library(stringr)
library(dplyr)
library(ggplot2)
library(readr)
```


# Inleiding 

---

Er zijn veel mogelijkheden om data te plotten in R. In deze sessie zullen we een aantal type plots behandelen:

* traditionele plots,
* ggplot2,
* interactieve plots.

<br>

# Traditional plots in R

---

Deze plots zijn sinds het begin van R al aanwezig, ik noem ze hier alleen even, maar ik wil er eigenlijk niet veel aandacht meer aan besteden omdat ik vond dat ze achterhaald zijn. Toch gebruik ik ze stiekum soms wel heel snel.

De algemene functie is `plot`, deze accepteert verschillende data structuren.

```{r, eval=FALSE, include=FALSE}
## vectoren
x = rnorm(100)
plot(x) 

y = runif(100)
plot(x,y)

plot(mtcars)
plot(mtcars %>% select(mpg,cyl,hp))

## histogram met hist
hist(x1)

## teksten op een plaatje 
plot(x,y)
text(x,y,"pp")
```


<br>

# De ggplot2 library van Hadley Wickham,  

---

The grammar of graphics: ggplot2. Een plot wordt gemaakt door layers op elkaar te leggen, elke laag kan worden beschreven met zogenaamde aesthetics (stijlen). Elke laag kan in een variabele opgeslagen worden en deze kunnen bij elkaar 'opgeteld' worden tot een uiteindelijke plot. 

Hieronder een eerste voorbeeldje van een ggplot op de `mtcars` data set.

```{r, eval=FALSE, include=FALSE}
## een laag p
p = ggplot(mtcars, aes(x=hp, y = mpg))

## wat is p
class(p)
typeof(p)

## voeg een laag punten toe
p = p + geom_point(alpha = 0.4)

## laat de plot zien door hem te printen
p

q = geom_point(aes(x = hp, y = cyl), col=2)
r = p + q
r

## Een titel is ook een laag
p = p + 
  ggtitle("AUTO PLOTS \n EEN VOORBEELDJE") 
p
```

De algemene graphing template in ggplot heeft de volgende vorm

```{r, eval=FALSE, include=FALSE}
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

## geom_... functies

Er zijn diverse geom_... functies, we zullen hieronder er een paar laten zien. 

Histogrammen zijn een handige manier om snel een indruk te krijgen van de verdeling van de data
```{r}
#### histogrammen
p = ggplot(data = mpg, aes(displ)) 
  
p + geom_histogram()

## er zijn diverse opties die je mee kunt geven
p+ geom_histogram(
  bins = 10,
  col="red",
  fill="green", 
  alpha = .82
) 
```

Box plots kan je ook gebruiken om een indruk te krijgen van de verdeling van de data. Ze bevatten visueel wat minder detail dan histogrammen, maar je kan er makkelijk een aantal naast elkaar zijn. We gebruiken de `mpg` data set en kijken naar de verdeling van highwat miles per gallon (hwy) voor verschillende type autos.

```{r}
p = ggplot(mpg, aes(class, hwy)) + geom_boxplot()
p
```

Je kan ook groupeerde boxplots maken en de volgorde van de boxplots wijzijgen, bijvoorbeeld op aflopende mediaan.

```{r}
p = ggplot(
  mpg,
  aes(
    reorder(
      class,
      hwy,
      median
    ),
  hwy, 
  fill = factor(year))) 
p + geom_boxplot()
```

## lijn grafieken

Lijn grafieken zijn handig om tijdreeksen te visualiseren

```{r}
df = data.frame(x=1:100, y=rnorm(100))

p = ggplot(
  df, 
  aes(x=x,y=y)
  )

p + geom_line()
p + geom_line(color="blue", size = 2)
```

When the x values are dates ggplot will take care of it!

```{r}
df = data.frame(
  x = anytime::anydate("2017-01-01") + 1:100,
  y = rnorm(100)
)

p = ggplot(
  df, 
  aes(x=x,y=y)
  )

p + geom_line()

```

## bar plots

bar plots zijn handig om aantallen te visualiseren.

```{r, fig.width=10, fig.height=8}
restaurants = read_csv("data/Restaurants.csv")

restaurants %>%
  group_by(keuken) %>%
  summarise(n=n()) %>%
  arrange(desc(n)) %>% 
  filter(!is.na(keuken)) %>%
  slice(1:10) %>%
  ggplot(aes(x=keuken)) + 
  geom_bar(aes(weight=n))

```

## geom_bin2d

Heatmaps of 2d bin plots kunnen handig zijn dense scatterplots wat inzichtelijker te maken

```{r}
df = data.frame(x=rnorm(100000), y=rnorm(100000))

ggplot(df, aes(x=x,y=y)) + geom_point()

ggplot(df, aes(x=x,y=y)) + geom_bin2d()
```



## facets in ggplot
Met `facets` kan je een matrix van plots maken. Een simpel voorbeeld is als je apart een histogram voor mannen en vrouwen wilt maken en dat naast elkaar of onder elkaar in een plot wilt zetten. Er zijn twee functies in ggplot2 die dit ondersteunen, `facet_grid` en `facet_wrap`

```{r}
## ik zie niks....
restaurants %>%
  ggplot(
    aes(x=aantalreviews)
  ) +
  geom_histogram() + 
facet_wrap(~keuken)

top10 = restaurants %>%
  group_by(keuken) %>%
  summarise(n=n()) %>%
  arrange(desc(n)) %>% 
  filter(!is.na(keuken)) %>%
  slice(1:10)

restaurants %>%
  inner_join(top10) %>%
  ggplot(
    aes(x=aantalreviews)
  ) + 
  geom_histogram() + facet_wrap(~keuken, ncol = 5)
```
```{r}
restaurants %>% filter(prijs < 100) %>%
  inner_join(top10) %>%
  ggplot(
    aes(x=aantalreviews, y = prijs)
  ) + 
  geom_point() + facet_wrap(~keuken, ncol = 5)
```

## grids
Met grids kun je verschillende ggplots in een plaatje krijgen. We hebben een helper functie (`multiplot`) nodig:

```{r}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

Nu kunnen we meerdere ggplots in een plaatje zetten. Hoe die meerdere plots op het canvas verschijnen kan je met een layout matrix opgeven.

```{r}
plots <- list() 

for (i in 1:5) {
    p1 = qplot(1:10, rnorm(10), main = i)
    plots[[i]] <- p1
}

layout <- matrix(c(1, 1, 2, 3, 4, 5), nrow = 2, byrow = TRUE)
multiplot(plotlist = plots, layout = layout)
```



## Assen en titels

Het is vaak nodig om assen en titels aan te passen. We geven hieronder een paar voorbeelden.

```{r}
## maak eerst een plot
p = ggplot(mtcars, aes(x=hp, y=cyl)) + geom_point()
p


p + scale_x_continuous("Dit is de HP")
p + ggtitle(" HP versus Cylinder")
p + scale_x_continuous("Dit is de HP", breaks = 50 + 20*1:10)

# log schale as
df = data.frame(x = exp(3*rnorm(100)), y = rnorm(100))
ggplot(df, aes(x,y)) + geom_point()

ggplot(df, aes(x,y)) + geom_point()+ scale_x_log10()
```

We zagen net al dat je met ggplot tijdreeksen kon plotten op baseis van date data. Gebruik `scale_x_date` om de as aan te passen.

```{r}
df = data.frame(
  x = anytime::anydate("2017-01-01") + 1:100,
  y = rnorm(100)
)

p = ggplot(
  df, 
  aes(x=x,y=y)
  )

p + geom_line() + scale_x_date(date_breaks = "1 week")
p + geom_line() + scale_x_date(date_breaks = "1 week", date_labels = "%d-%m")

```

Er is een aardige 'cheatsheet' voor ggplot2. Deze bevat beknopt een overzicht van de verschillende mogelijkheden en kan je vinden op [ggplot2 cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf)

<br>

# Interactive grafieken

---
Naast de statistsiche grafieken die we hierboven hebben gemaakt kan ke in R ook interactieve grafieken maken. We geven in deze sectie een aantal voorbeelden.

## ggvis, vergelijkbaar met ggplot

```{r}
library(ggvis)

ggvis(mtcars,~mpg)
ggvis(mtcars,~mpg, ~wt)

# ggvis werkt met %>% chain operator ipv + operator
# handig voor gelaagde plots   (layers)

mtcars %>% ggvis(~factor(cyl), ~mpg) 
mtcars %>% ggvis(~factor(cyl), ~mpg) %>% layer_boxplots()


mtcars %>%
  ggvis(~mpg, ~wt) %>%
  layer_points() %>%
  layer_smooths()


### met wat controls-sturing...

mtcars %>%
  ggvis(~wt, ~mpg) %>%
  layer_smooths(span = input_slider(0.5, 1, value = 1)) %>%
  layer_points(size := input_slider(100, 1000, value = 100))

```


## ploty

Plotly is een mooie library voor het maken van interactive visualisaties. Zie voor meer info [plotly](https://plot.ly/r/)

### scatters

### barcharts

### 3D surface plots



## leaflet

Leaflets worden gebruikt om interactieve kaartjes te maken. Ze gebruiken open street maps.

```{r}
library(leaflet)

m <- leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng=174.768, lat=-36.852, popup = "The birthplace of R")
m  

# kan geblokt worden door fire walls.
```

Plot de restaurants in Zwolle op een kaartje. Data van Iens gescraped.

```{r}
Restaurants <- readr::read_csv("data/Restaurants.csv")
Zwolle = Restaurants %>% filter(plaats == "Zwolle")

## tooltip teksten kunnen geplaatst worden
ptekst = paste(Zwolle$restNamen, '<BR> aantal reviews: ', Zwolle$aantalreviews)

m2 = leaflet(data = Zwolle)
m2 = m2 %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng = ~LONGs, lat = ~LATs, popup = ptekst)
m2  
```

Je kan kleurtje gebruiken, gebruik dan `addCirclemarkers`

```{r}
reds = colorNumeric("Reds", domain = NULL)

Zwolle = Zwolle %>% filter(!is.na(aantalreviews), aantalreviews < 80)
ptekst = paste(Zwolle$restNamen, '<BR> aantal reviews: ', Zwolle$aantalreviews)

m2 = leaflet(data = Zwolle)
m2 = m2 %>%
  addTiles() %>%
  addCircleMarkers(lng = ~LONGs, lat = ~LATs, fillColor = ~reds(aantalreviews), fillOpacity = 1, popup = ptekst)
m2

```



## Netwerk grafieken, visnetwork

Het package `visnetwork` kan worden gebruikt om interactieve netwerk grafieken te maken. Je hebt twee data frames nodig, een met de nodes en een met de edges. Laten we beginnen met een simpel voorbeeldje.

```{r}
library(visNetwork)

nodes = data.frame(
  id = c(1,2,3,4)
)
edges = data.frame(
  from = c(1,3,4), 
  to  = c(2,2,2)
)

visNetwork(nodes, edges)
```


Er zijn diverse opties die je kan meegeven. Een deel van de opties kan je via de data frames meegeven.

```{r}
nodes <- data.frame(
  id = 1:10,
  label = paste("Node", 1:10),                                   # labels
  group = c("GrA", "GrB"),                                       # groups
  value = 1:10,                                                  # size
  shape = c("square", "triangle", "box", "circle", "dot", "star", "ellipse", "database", "text", "diamond"),           # shape
  title = paste0("<p><b>", 1:10,"</b><br>Node !</p>"),           # tooltip
  color = c("darkred", "grey", "orange", "darkblue", "purple"),  # color
  shadow = c(FALSE, TRUE, FALSE, TRUE, TRUE))                    # shadow

edges <- data.frame(from = sample(1:10,8), to = sample(1:10, 8),
  label = paste("Edge", 1:8),                                 # labels
  length = c(100,500),                                        # length
  arrows = c("to", "from", "middle", "middle;to"),            # arrows
  dashes = c(TRUE, FALSE),                                    # dashes
  title = paste("Edge", 1:8),                                 # tooltip
  smooth = c(FALSE, TRUE),                                    # smooth
  shadow = c(FALSE, TRUE, FALSE, TRUE))                       # shadow

visNetwork(nodes, edges)
```


Andere opties kan je via de functie `visnetwork` meegeven. Bijvoorbeeld highlight nearest

```{r}
nodes <- data.frame(id = 1:15, label = paste("Label", 1:15),
                    group = sample(LETTERS[1:3], 15, replace = TRUE))

edges <- data.frame(from = trunc(runif(15)*(15-1))+1,
                    to = trunc(runif(15)*(15-1))+1)

visNetwork(nodes, edges) %>% visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)


```

Nog een netwerk voorbeeldje van restaurant bezoekers in het mooie stadje Hoorn. Vereist wat data gewroet.... maar dat is vaak zo :-)

Lees eerst link data in.
```{r}
RestaurantLinks <- readRDS("data/RestaurantLinks.RDs")

## bevat vanuit iens.nl per regel een restaurant link.
## als 5 reviewers van restaurant A ook restaurant B gerievewd hebben: dan staat er A  B  5

head(RestaurantLinks[,c(1,4,7)], n=10)

```

Focus nu alleen op het mooie stadje Hoorn

```{r}
stadje = "hoorn"

### Filter hoorn er uit in de links en in de restaurant set
fil1 = RestaurantLinks$IensLink %>% 
  str_detect(stadje)
fil2 = RestaurantLinks$IensLink1 %>% 
  str_detect(stadje)

Hoorn  = filter(RestaurantLinks, fil1 & fil2  )

### Opschonen restaurant naam, dit moet je doen anders krijg je een error bij publiceren
Hoorn$RestaurantNaam = iconv(Hoorn$RestaurantNaam, "latin1", "ASCII")
Hoorn$RestaurantNaam1 = iconv(Hoorn$RestaurantNaam1, "latin1", "ASCII")

strf2 = "\\bHoorn\\b"
HoornR = Restaurants$plaats  %>% str_detect(strf2)
HoornRes = filter(Restaurants, HoornR)
HoornRes$keuken = iconv(HoornRes$keuken, "latin1", "ASCII")

head(HoornRes)
```

destileer de unieke nodes en edges uit de data en plot de netwerkgrafiek

```{r}
tmp  = data.frame(restNamen = unique( c(unique(Hoorn$RestaurantNaam), unique(Hoorn$RestaurantNaam1))))
tmp2 = left_join (tmp, HoornRes, by="restNamen") %>% filter( !is.na(restNamen))

Hoornnodes = data.frame(
  id    = tmp2$restNamen,
  label = tmp2$restNamen,
  title = tmp2$restNamen,
  group = tmp2$keuken
)

HoornEdges = data.frame(
  from  = Hoorn$RestaurantNaam,
  to    = Hoorn$RestaurantNaam1, 
  value = Hoorn$COUNT_of_IensLink1
)  

#### zet bezoekers van restaurant A naar restaurant A op 1
HoornEdges$value [Hoorn$RestaurantNaam == Hoorn$RestaurantNaam1] = 1

visNetwork(Hoornnodes, HoornEdges) %>% 
  visLegend() %>%
  visOptions(
    highlightNearest = TRUE, 
    nodesIdSelection = TRUE
  ) %>%
  visInteraction(
    navigationButtons = TRUE
  ) %>%
  visPhysics( maxVelocity = 25)

```



